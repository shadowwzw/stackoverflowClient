{
  "items": [
    {
      "owner": {
        "reputation": 43,
        "user_id": 1673396,
        "user_type": "registered",
        "profile_image": "https://i.stack.imgur.com/yA8Jv.jpg?s=128&g=1",
        "display_name": "Michael Zheng",
        "link": "https://stackoverflow.com/users/1673396/michael-zheng"
      },
      "is_accepted": false,
      "score": 0,
      "last_activity_date": 1524818603,
      "creation_date": 1524818603,
      "answer_id": 50058587,
      "question_id": 57483,
      "body": "<p>Taryn♦ said\n\"You can't take the address of a reference like you can with pointers.\".</p>\n\n<p>Actually you can.</p>\n\n<p>I'm quoting from another question:</p>\n\n<p>\"The C++ FAQ says it best:</p>\n\n<p>Unlike a pointer, once a reference is bound to an object, it can not be \"reseated\" to another object. The reference itself isn't an object (it has no identity; taking the address of a reference gives you the address of the referent; remember: the reference is its referent).\"</p>\n"
    },
    {
      "owner": {
        "reputation": 16919,
        "user_id": 3458,
        "user_type": "registered",
        "accept_rate": 68,
        "profile_image": "https://i.stack.imgur.com/xfv2y.png?s=128&g=1",
        "display_name": "Arkadiy",
        "link": "https://stackoverflow.com/users/3458/arkadiy"
      },
      "is_accepted": false,
      "score": 89,
      "last_activity_date": 1523548784,
      "last_edit_date": 1523548784,
      "creation_date": 1221163649,
      "answer_id": 57490,
      "question_id": 57483,
      "body": "<p>Apart from syntactic sugar, a reference is a <code>const</code> pointer (<em>not</em> pointer to a <code>const</code>). You must establish what it refers to when you declare the reference variable, and you cannot change it later.</p>\n\n<p>Update: now that I think about it some more, there is an important difference.</p>\n\n<p>A const pointer's target can be replaced by taking its address and using a const cast.</p>\n\n<p>A reference's target cannot be replaced in any way short of UB.</p>\n\n<p>This should permit the compiler to do more optimization on a reference.</p>\n"
    },
    {
      "owner": {
        "reputation": 237813,
        "user_id": 3153,
        "user_type": "registered",
        "accept_rate": 98,
        "profile_image": "https://www.gravatar.com/avatar/47d8644c0ad8d89635fca422dd6d3ab5?s=128&d=identicon&r=PG",
        "display_name": "Brian R. Bondy",
        "link": "https://stackoverflow.com/users/3153/brian-r-bondy"
      },
      "is_accepted": false,
      "community_owned_date": 1221791478,
      "score": 1325,
      "last_activity_date": 1517007495,
      "last_edit_date": 1517007495,
      "creation_date": 1221163700,
      "answer_id": 57492,
      "question_id": 57483,
      "body": "<ol>\n<li><p>A pointer can be re-assigned: </p>\n\n<pre><code>int x = 5;\nint y = 6;\nint *p;\np =  &amp;x;\np = &amp;y;\n*p = 10;\nassert(x == 5);\nassert(y == 10);\n</code></pre>\n\n<p>A reference cannot, and must be assigned at initialization:</p>\n\n<pre><code>int x = 5;\nint y = 6;\nint &amp;r = x;\n</code></pre></li>\n<li><p>A pointer has its own memory address and size on the stack (4 bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack.  Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name for the same variable.  Note: What a pointer points to can be on the stack or heap.  Ditto a reference. My claim in this statement is not that a pointer must point to the stack.  A pointer is just a variable that holds a memory address.  This variable is on the stack.  Since a reference has its own space on the stack, and since the address is the same as the variable it references.  More on <a href=\"https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936\">stack vs heap</a>.  This implies that there is a real address of a reference that the compiler will not tell you. </p>\n\n<pre><code>int x = 0;\nint &amp;r = x;\nint *p = &amp;x;\nint *p2 = &amp;r;\nassert(p == p2);\n</code></pre></li>\n<li><p>You can have pointers to pointers to pointers offering extra levels of indirection.  Whereas references only offer one level of indirection. </p>\n\n<pre><code>int x = 0;\nint y = 0;\nint *p = &amp;x;\nint *q = &amp;y;\nint **pp = &amp;p;\npp = &amp;q;//*pp = q\n**pp = 4;\nassert(y == 4);\nassert(x == 0);\n</code></pre></li>\n<li><p>Pointer can be assigned <code>nullptr</code> directly, whereas reference cannot. If you try hard enough, and you know how, you can make the address of a reference <code>nullptr</code>.  Likewise, if you try hard enough you can have a reference to a pointer, and then that reference can contain <code>nullptr</code>.</p>\n\n<pre><code>int *p = nullptr;\nint &amp;r = nullptr; &lt;--- compiling error\nint &amp;r = *p;  &lt;--- likely no compiling error, especially if the nullptr is hidden behind a function call, yet it refers to a non-existent int at address 0\n</code></pre></li>\n<li><p>Pointers can iterate over an array, you can use <code>++</code> to go to the next item that a pointer is pointing to, and <code>+ 4</code> to go to the 5th element.  This is no matter what size the object is that the pointer points to.</p></li>\n<li><p>A pointer needs to be dereferenced with <code>*</code> to access the memory location it points to, whereas a reference can be used directly.  A pointer to a class/struct uses <code>-&gt;</code> to access it's members whereas a reference uses a <code>.</code>.</p></li>\n<li><p>A pointer is a variable that holds a memory address.  Regardless of how a reference is implemented, a reference has the same memory address as the item it references.</p></li>\n<li><p>References cannot be stuffed into an array, whereas pointers can be (Mentioned by user @litb)</p></li>\n<li><p>Const references can be bound to temporaries. Pointers cannot (not without some indirection):</p>\n\n<pre><code>const int &amp;x = int(12); //legal C++\nint *y = &amp;int(12); //illegal to dereference a temporary.\n</code></pre>\n\n<p>This makes <code>const&amp;</code> safer for use in argument lists and so forth.</p></li>\n</ol>\n"
    },
    {
      "owner": {
        "reputation": 212304,
        "user_id": 5987,
        "user_type": "registered",
        "accept_rate": 55,
        "profile_image": "https://www.gravatar.com/avatar/2a1f9f4986b58015691eb2014e78869f?s=128&d=identicon&r=PG",
        "display_name": "Mark Ransom",
        "link": "https://stackoverflow.com/users/5987/mark-ransom"
      },
      "is_accepted": false,
      "score": 96,
      "last_activity_date": 1515452262,
      "last_edit_date": 1515452262,
      "creation_date": 1221167209,
      "answer_id": 57656,
      "question_id": 57483,
      "body": "<p>Contrary to popular opinion, it is possible to have a reference that is NULL.</p>\n\n<pre><code>int * p = NULL;\nint &amp; r = *p;\nr = 1;  // crash! (if you're lucky)\n</code></pre>\n\n<p>Granted, it is much harder to do with a reference - but if you manage it, you'll tear your hair out trying to find it. References are <em>not</em> inherently safe in C++!</p>\n\n<p>Technically this is an <strong>invalid reference</strong>, not a null reference.  C++ doesn't support null references as a concept as you might find in other languages.  There are other kinds of invalid references as well. <em>Any</em> invalid reference raises the spectre of <strong>undefined behavior</strong>, just as using an invalid pointer would.</p>\n\n<p>The actual error is in the dereferencing of the NULL pointer, prior to the assignment to a reference.  But I'm not aware of any compilers that will generate any errors on that condition - the error propagates to a point further along in the code. That's what makes this problem so insidious. Most of the time, if you dereference a NULL pointer, you crash right at that spot and it doesn't take much debugging to figure it out.</p>\n\n<p>My example above is short and contrived. Here's a more real-world example.</p>\n\n<pre><code>class MyClass\n{\n    ...\n    virtual void DoSomething(int,int,int,int,int);\n};\n\nvoid Foo(const MyClass &amp; bar)\n{\n    ...\n    bar.DoSomething(i1,i2,i3,i4,i5);  // crash occurs here due to memory access violation - obvious why?\n}\n\nMyClass * GetInstance()\n{\n    if (somecondition)\n        return NULL;\n    ...\n}\n\nMyClass * p = GetInstance();\nFoo(*p);\n</code></pre>\n\n<p>I want to reiterate that the only way to get a null reference is through malformed code, and once you have it you're getting undefined behavior. It <strong>never</strong> makes sense to check for a null reference; for example you can try <code>if(&amp;bar==NULL)...</code> but the compiler might optimize the statement out of existence! A valid reference can never be NULL so from the compiler's view the comparison is always false, and it is free to eliminate the <code>if</code> clause as dead code - this is the essence of undefined behavior.</p>\n\n<p>The proper way to stay out of trouble is to avoid dereferencing a NULL pointer to create a reference. Here's an automated way to accomplish this.</p>\n\n<pre><code>template&lt;typename T&gt;\nT&amp; deref(T* p)\n{\n    if (p == NULL)\n        throw std::invalid_argument(std::string(\"NULL reference\"));\n    return *p;\n}\n\nMyClass * p = GetInstance();\nFoo(deref(p));\n</code></pre>\n\n<p>For an older look at this problem from someone with better writing skills, see <a href=\"http://www.gotw.ca/conv/002.htm\" rel=\"noreferrer\">Null References</a> from Jim Hyslop and Herb Sutter.</p>\n\n<p>For another example of the dangers of dereferencing a null pointer see <a href=\"https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635\" rel=\"noreferrer\">Exposing undefined behavior when trying to port code to another platform</a> by Raymond Chen.</p>\n"
    },
    {
      "owner": {
        "reputation": 306,
        "user_id": 3203817,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/2f81efff47d429c32515d29ee4f11a02?s=128&d=identicon&r=PG",
        "display_name": "Immac",
        "link": "https://stackoverflow.com/users/3203817/immac"
      },
      "is_accepted": false,
      "score": 1,
      "last_activity_date": 1510445142,
      "last_edit_date": 1510445142,
      "creation_date": 1510441191,
      "answer_id": 47243714,
      "question_id": 57483,
      "body": "<p>I have an analogy for references and pointers, think of references as another name for an object and pointers as the address of an object.</p>\n\n<pre><code>// receives an alias of an int, an address of an int and an int value\npublic void my_function(int&amp; a,int* b,int c){\n    int d = 1; // declares an integer named d\n    int &amp;e = d; // declares that e is an alias of d\n    // using either d or e will yield the same result as d and e name the same object\n    int *f = e; // invalid, you are trying to place an object in an address\n    // imagine writting your name in an address field \n    int *g = f; // writes an address to an address\n    g = &amp;d; // &amp;d means get me the address of the object named d you could also\n    // use &amp;e as it is an alias of d and write it on g, which is an address so it's ok\n}\n</code></pre>\n"
    },
    {
      "owner": {
        "reputation": 2530,
        "user_id": 7008416,
        "user_type": "registered",
        "accept_rate": 100,
        "profile_image": "https://www.gravatar.com/avatar/1aa92fca6ba297f9420e519fd789ac64?s=128&d=identicon&r=PG&f=1",
        "display_name": "Arthur Tacca",
        "link": "https://stackoverflow.com/users/7008416/arthur-tacca"
      },
      "is_accepted": false,
      "score": 0,
      "last_activity_date": 1509621362,
      "creation_date": 1509621362,
      "answer_id": 47073963,
      "question_id": 57483,
      "body": "<p>There is a very important non-technical different between pointers and references: A argument passed to a function by pointer is much more visible than an argument passed to a function by non-const reference. For example:</p>\n\n<pre><code>void fn1(std::string s);\nvoid fn2(const std::string&amp; s);\nvoid fn3(std::string&amp; s);\nvoid fn4(std::string* s);\n\nvoid bar() {\n    std::string x;\n    fn1(x);  // Cannot modify x\n    fn2(x);  // Cannot modify x (without const_cast)\n    fn3(x);  // CAN modify x!\n    fn4(&amp;x); // Can modify x (but is obvious about it)\n}\n</code></pre>\n\n<p>Back in C, a call that looks like <code>fn(x)</code> can only be pass by value, so it definitely cannot modify <code>x</code>; to modify an argument you would need to pass a pointer <code>fn(&amp;x)</code>. So if an argument wasn't preceeded by an <code>&amp;</code> you knew it would not be modified. (The converse, <code>&amp;</code> means modified, was not true because you would sometimes have to pass large read-only structures by <code>const</code> pointer.)</p>\n\n<p>Some argue that this is such a useful feature when reading code, that pointer parameters should always be used for modifiable parameters rather than non-<code>const</code> references, even if the function never expects a <code>nullptr</code>. That is, those people argue that function signatures like <code>fn3()</code> above should not be allowed. <a href=\"http://google.github.io/styleguide/cppguide.html#Reference_Arguments\" rel=\"nofollow noreferrer\">Google's C++ style guidelines</a> are an example of this.</p>\n"
    },
    {
      "owner": {
        "reputation": 326,
        "user_id": 3027604,
        "user_type": "registered",
        "accept_rate": 80,
        "profile_image": "https://i.stack.imgur.com/wUHYR.jpg?s=128&g=1",
        "display_name": "Hitokage",
        "link": "https://stackoverflow.com/users/3027604/hitokage"
      },
      "is_accepted": false,
      "score": 1,
      "last_activity_date": 1508413817,
      "creation_date": 1508413817,
      "answer_id": 46829217,
      "question_id": 57483,
      "body": "<p>I always decide by <a href=\"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#f60-prefer-t-over-t-when-no-argument-is-a-valid-option\" rel=\"nofollow noreferrer\">this</a> rule from C++ Core Guidelines:</p>\n\n<blockquote>\n  <p>Prefer T* over T&amp; when \"no argument\" is a valid option</p>\n</blockquote>\n"
    },
    {
      "owner": {
        "reputation": 2263,
        "user_id": 6350858,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/0bfeae5d1ddef3ed5e81e88bdd30063f?s=128&d=identicon&r=PG&f=1",
        "display_name": "Ap31",
        "link": "https://stackoverflow.com/users/6350858/ap31"
      },
      "is_accepted": false,
      "score": 8,
      "last_activity_date": 1499370526,
      "creation_date": 1499370526,
      "answer_id": 44957687,
      "question_id": 57483,
      "body": "<p>I feel like there is yet another point that hasn't been covered here.  </p>\n\n<p>Unlike the pointers, references are <strong>syntactically equivalent</strong> to the object they refer to, i.e. any operation that can be applied to an object works for a reference, and with the exact same syntax (the exception is of course the initialization).  </p>\n\n<p>While this may appear superficial, I believe this property is crucial for a number of C++ features, for example:  </p>\n\n<ul>\n<li><p><em>Templates</em>. Since template parameters are duck-typed, syntactic properties of a type is all that matters, so often the same template can be used with both <code>T</code> and <code>T&amp;</code>.<br>\n(or <code>std::reference_wrapper&lt;T&gt;</code> which still relies on an implicit cast\nto <code>T&amp;</code>)<br>\nTemplates that cover both <code>T&amp;</code> and <code>T&amp;&amp;</code> are even more common.   </p></li>\n<li><p><em>Lvalues</em>. Consider the statement <code>str[0] = 'X';</code> Without references it would only work for c-strings (<code>char* str</code>). Returning the character by reference allows user-defined classes to have the same notation.  </p></li>\n<li><p><em>Copy constructors</em>. Syntactically it makes sense to pass objects to copy constructors, and not pointers to objects. But there is just no way for a copy constructor to take an object by value - it would result in a recursive call to the same copy constructor. This leaves references as the only option here.  </p></li>\n<li><p><em>Operator overloads</em>. With references it is possible to introduce indirection to an operator call - say, <code>operator+(const T&amp; a, const T&amp; b)</code> while retaining the same infix notation. This also works for regular overloaded functions.  </p></li>\n</ul>\n\n<p>These points empower a considerable part of C++ and the standard library so this is quite a major property of references.</p>\n"
    },
    {
      "owner": {
        "reputation": 108,
        "user_id": 7383437,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/a6d91187498bdb798e42e29eda5f0259?s=128&d=identicon&r=PG&f=1",
        "display_name": "dhokar.w",
        "link": "https://stackoverflow.com/users/7383437/dhokar-w"
      },
      "is_accepted": false,
      "score": 5,
      "last_activity_date": 1486561399,
      "last_edit_date": 1486561399,
      "creation_date": 1483711270,
      "answer_id": 41507371,
      "question_id": 57483,
      "body": "<h3>Difference between pointer and reference</h3>\n\n<p>A pointer can be initialized to 0 and a reference not. In fact, a reference must also refer to an object, but a pointer can be the null pointer:</p>\n\n<pre><code>int* p = 0;\n</code></pre>\n\n<p>But we can’t have <code>int&amp; p = 0;</code> and also <code>int&amp; p=5 ;</code>.</p>\n\n<p>In fact to do it properly, we must have declared and defined an object at the first then we can make a reference to that object, so the correct implementation of the previous code will be:</p>\n\n<pre><code>Int x = 0;\nInt y = 5;\nInt&amp; p = x;\nInt&amp; p1 = y;\n</code></pre>\n\n<p>Another important point is that is we can make the declaration of the pointer without initialization however no such thing can be done in case of reference which must make a reference always to variable or object. However such use of a pointer is risky so generally we check if the pointer is actually is pointing to something or not. In case of a reference no such check is necessary, because we know already that referencing to an object during declaration is mandatory.</p>\n\n<p>Another difference is that pointer can point to another object however reference is always referencing to the same object, let’s take this example:</p>\n\n<pre><code>Int a = 6, b = 5;\nInt&amp; rf = a;\n\nCout &lt;&lt; rf &lt;&lt; endl; // The result we will get is 6, because rf is referencing to the value of a.\n\nrf = b;\ncout &lt;&lt; a &lt;&lt; endl; // The result will be 5 because the value of b now will be stored into the address of a so the former value of a will be erased\n</code></pre>\n\n<p>Another point: When we have a template like an STL template such kind of a class template will always return a reference, not a pointer, to make easy reading or assigning new value using operator []:</p>\n\n<pre><code>Std ::vector&lt;int&gt;v(10); // Initialize a vector with 10 elements\nV[5] = 5; // Writing the value 5 into the 6 element of our vector, so if the returned type of operator [] was a pointer and not a reference we should write this *v[5]=5, by making a reference we overwrite the element by using the assignment \"=\"\n</code></pre>\n"
    },
    {
      "owner": {
        "reputation": 309,
        "user_id": 2002964,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/610572ce8c4d1b76985a011db795823a?s=128&d=identicon&r=PG",
        "display_name": "tanweer alam",
        "link": "https://stackoverflow.com/users/2002964/tanweer-alam"
      },
      "is_accepted": false,
      "score": 14,
      "last_activity_date": 1484012779,
      "last_edit_date": 1484012779,
      "creation_date": 1361856032,
      "answer_id": 15081923,
      "question_id": 57483,
      "body": "<p>A reference is not another name given to some memory. It's a immutable pointer that is automatically de-referenced on usage. Basically it boils down to:</p>\n\n<pre><code>int&amp; j = i;\n</code></pre>\n\n<p>It internally becomes</p>\n\n<pre><code>int* const j = &amp;i;\n</code></pre>\n"
    },
    {
      "owner": {
        "reputation": 412,
        "user_id": 1466198,
        "user_type": "registered",
        "accept_rate": 87,
        "profile_image": "https://www.gravatar.com/avatar/4de5043213dc8ec56e157fddf3dcff45?s=128&d=identicon&r=PG",
        "display_name": "Zorgiev",
        "link": "https://stackoverflow.com/users/1466198/zorgiev"
      },
      "is_accepted": false,
      "score": 4,
      "last_activity_date": 1461504473,
      "last_edit_date": 1461504473,
      "creation_date": 1461504140,
      "answer_id": 36823688,
      "question_id": 57483,
      "body": "<p>The difference is that non-constant pointer variable(not to be confused with a pointer to constant) may be changed at some time during program execution, requires pointer semantics to be used(&amp;,*) operators, while references can be set upon initialization only(that's why you can set them in constructor initializer list only, but not somehow else) and use ordinary value accessing semantics.  Basically references were introduced to allow support for operators overloading as I had read in some very old book. As somebody stated in this thread - pointer can be set to 0 or whatever value you want. 0(NULL, nullptr) means that the pointer is initialized with nothing. It is an error to dereference null pointer. But actually the pointer may contain a value that doesn't point to some correct memory location. References in their turn try not to allow a user to initialize a reference to something that cannot be referenced due to the fact that you always provide rvalue of correct type to it. Although there are a lot of ways to make reference variable be initialized to a wrong memory location - it is better for you not to dig this deep into details. On machine level both pointer and reference work uniformly - via pointers. Let's say in essential references are syntactic sugar. rvalue references are different to this - they are naturally stack/heap objects.</p>\n"
    },
    {
      "owner": {
        "reputation": 1403,
        "user_id": 3725702,
        "user_type": "registered",
        "accept_rate": 40,
        "profile_image": "https://www.gravatar.com/avatar/dbfd045abca529ddaa84e83ff01048d2?s=128&d=identicon&r=PG&f=1",
        "display_name": "Yogeesh H T",
        "link": "https://stackoverflow.com/users/3725702/yogeesh-h-t"
      },
      "is_accepted": false,
      "score": 10,
      "last_activity_date": 1449050447,
      "last_edit_date": 1449050447,
      "creation_date": 1449049288,
      "answer_id": 34039390,
      "question_id": 57483,
      "body": "<p>Both references and pointers can be used to change local variables of one function inside another function. Both of them can also be used to save copying of big objects when passed as arguments to functions or returned from functions, to get efficiency gain.\nDespite above similarities, there are following differences between references and pointers.</p>\n\n<p><strong>References are less powerful than pointers</strong></p>\n\n<p>1) Once a reference is created, it cannot be later made to reference another object; it cannot be reseated. This is often done with pointers.</p>\n\n<p>2) References cannot be NULL. Pointers are often made NULL to indicate that they are not pointing to any valid thing.</p>\n\n<p>3) A reference must be initialized when declared. There is no such restriction with pointers</p>\n\n<p><em>Due to the above limitations, references in C++ cannot be used for implementing data structures like Linked List, Tree, etc. In Java, references don’t have above restrictions, and can be used to implement all data structures. References being more powerful in Java, is the main reason Java doesn’t need pointers.</em></p>\n\n<p><strong>References are safer and easier to use:</strong></p>\n\n<p>1) Safer: Since references must be initialized, wild references like wild pointers are unlikely to exist. It is still possible to have references that don’t refer to a valid location </p>\n\n<p>2) Easier to use: References don’t need dereferencing operator to access the value. They can be used like normal variables. ‘&amp;’ operator is needed only at the time of declaration. Also, members of an object reference can be accessed with dot operator (‘.’), unlike pointers where arrow operator (->) is needed to access members.</p>\n\n<p><em>Together with the above reasons, there are few places like copy constructor argument where pointer cannot be used. Reference must be used pass the argument in copy constructor. Similarly <strong>references must be used for overloading some operators like ++</strong>.</em></p>\n"
    },
    {
      "owner": {
        "reputation": 871,
        "user_id": 731433,
        "user_type": "registered",
        "accept_rate": 62,
        "profile_image": "https://www.gravatar.com/avatar/1696bdda51de5e245f16d5cebfd1f7b1?s=128&d=identicon&r=PG&f=1",
        "display_name": "Kunal Vyas",
        "link": "https://stackoverflow.com/users/731433/kunal-vyas"
      },
      "is_accepted": false,
      "score": 30,
      "last_activity_date": 1445642212,
      "last_edit_date": 1445642212,
      "creation_date": 1305919597,
      "answer_id": 6076707,
      "question_id": 57483,
      "body": "<p>While both references and pointers are used to indirectly access another value, there are two important differences between references and pointers. The first is that a reference always refers to an object: It is an error to define a reference without initializing it. The behavior of assignment is the second important difference: Assigning to a reference changes the object to which the reference is bound; it does not rebind the reference to another object. Once initialized, a reference always refers to the same underlying object.</p>\n\n<p>Consider these two program fragments. In the first, we assign one pointer to another:</p>\n\n<pre><code>int ival = 1024, ival2 = 2048;\nint *pi = &amp;ival, *pi2 = &amp;ival2;\npi = pi2;    // pi now points to ival2\n</code></pre>\n\n<p>After the assignment, ival, the object addressed by pi remains unchanged. The assignment changes the value of pi, making it point to a different object. Now consider a similar program that assigns two references:</p>\n\n<pre><code>int &amp;ri = ival, &amp;ri2 = ival2;\nri = ri2;    // assigns ival2 to ival\n</code></pre>\n\n<p>This assignment changes ival, the value referenced by ri, and not the reference itself. After the assignment, the two references still refer to their original objects, and the value of those objects is now the same as well.</p>\n"
    },
    {
      "owner": {
        "reputation": 6713,
        "user_id": 3777958,
        "user_type": "registered",
        "accept_rate": 95,
        "profile_image": "https://i.stack.imgur.com/vItgV.png?s=128&g=1",
        "display_name": "Destructor",
        "link": "https://stackoverflow.com/users/3777958/destructor"
      },
      "is_accepted": false,
      "score": 13,
      "last_activity_date": 1436346384,
      "last_edit_date": 1436346384,
      "creation_date": 1423487836,
      "answer_id": 28410732,
      "question_id": 57483,
      "body": "<p>A reference to a pointer is possible in C++, but the reverse is not possible means a pointer to a reference isn't possible. A reference to a pointer provides a cleaner syntax to modify the pointer.\nLook at this example:</p>\n\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nvoid swap(char * &amp;str1, char * &amp;str2)\n{\n  char *temp = str1;\n  str1 = str2;\n  str2 = temp;\n}\n\nint main()\n{\n  char *str1 = \"Hi\";\n  char *str2 = \"Hello\";\n  swap(str1, str2);\n  cout&lt;&lt;\"str1 is \"&lt;&lt;str1&lt;&lt;endl;\n  cout&lt;&lt;\"str2 is \"&lt;&lt;str2&lt;&lt;endl;\n  return 0;\n}\n</code></pre>\n\n<p>And consider the C version of the above program. In C you have to use pointer to pointer (multiple indirection), and it leads to confusion and the program may look complicated.</p>\n\n<pre><code>#include&lt;stdio.h&gt;\n/* Swaps strings by swapping pointers */\nvoid swap1(char **str1_ptr, char **str2_ptr)\n{\n  char *temp = *str1_ptr;\n  *str1_ptr = *str2_ptr;\n  *str2_ptr = temp;\n}\n\nint main()\n{\n  char *str1 = \"Hi\";\n  char *str2 = \"Hello\";\n  swap1(&amp;str1, &amp;str2);\n  printf(\"str1 is %s, str2 is %s\", str1, str2);\n  return 0;\n}\n</code></pre>\n\n<p>Visit the following for more information about reference to pointer:</p>\n\n<ul>\n<li><em><a href=\"http://markgodwin.blogspot.in/2009/08/c-reference-to-pointer.html\">C++: Reference to Pointer</a></em></li>\n<li><em><a href=\"http://www.codeguru.com/cpp/cpp/cpp_mfc/pointers/article.php/c4089/PointertoPointer-and-ReferencetoPointer.htm\">Pointer-to-Pointer and Reference-to-Pointer</a></em></li>\n</ul>\n\n<p>As I said, a pointer to a reference isn't possible. Try the following program:</p>\n\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n   int x = 10;\n   int *ptr = &amp;x;\n   int &amp;*ptr1 = ptr;\n}\n</code></pre>\n"
    },
    {
      "owner": {
        "reputation": 319,
        "user_id": 2143209,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/964200984e199bc9fc52c8273a9effb7?s=128&d=identicon&r=PG",
        "display_name": "Life",
        "link": "https://stackoverflow.com/users/2143209/life"
      },
      "is_accepted": false,
      "score": 15,
      "last_activity_date": 1436304957,
      "last_edit_date": 1436304957,
      "creation_date": 1389618856,
      "answer_id": 21092239,
      "question_id": 57483,
      "body": "<p>This is based on the <a href=\"http://www.cplusplus.com/files/tutorial.pdf\">tutorial</a>. What is written makes it more clear:</p>\n\n<pre><code>&gt;&gt;&gt; The address that locates a variable within memory is\n    what we call a reference to that variable. (5th paragraph at page 63)\n\n&gt;&gt;&gt; The variable that stores the reference to another\n    variable is what we call a pointer. (3rd paragraph at page 64)\n</code></pre>\n\n<p>Simply to remember that,</p>\n\n<pre><code>&gt;&gt;&gt; reference stands for memory location\n&gt;&gt;&gt; pointer is a reference container (Maybe because we will use it for\nseveral times, it is better to remember that reference.)\n</code></pre>\n\n<p>What's more, as we can refer to almost any pointer tutorial, a pointer is an object that is supported by pointer arithmetic which makes pointer similar to an array.</p>\n\n<p>Look at the following statement,</p>\n\n<pre><code>int Tom(0);\nint &amp; alias_Tom = Tom;\n</code></pre>\n\n<p><code>alias_Tom</code> can be understood as an <code>alias of a variable</code> (different with <code>typedef</code>, which is <code>alias of a type</code>) <code>Tom</code>. It is also OK to forget the terminology of such statement is to create a reference of <code>Tom</code>.</p>\n"
    },
    {
      "owner": {
        "reputation": 5232,
        "user_id": 2728148,
        "user_type": "registered",
        "accept_rate": 50,
        "profile_image": "https://www.gravatar.com/avatar/b8986ca710483168127d445d42f41238?s=128&d=identicon&r=PG&f=1",
        "display_name": "Cort Ammon",
        "link": "https://stackoverflow.com/users/2728148/cort-ammon"
      },
      "is_accepted": false,
      "score": 49,
      "last_activity_date": 1436304879,
      "last_edit_date": 1436304879,
      "creation_date": 1378007081,
      "answer_id": 18555015,
      "question_id": 57483,
      "body": "<p>References are very similar to pointers, but they are specifically crafted to be helpful to optimizing compilers.</p>\n\n<ul>\n<li>References are designed such that it is substantially easier for the compiler to trace which reference aliases which variables. Two major features are very important: no \"reference arithmetic\" and no reassigning of references. These allow the compiler to figure out which references alias which variables at compile time.</li>\n<li>References are allowed to refer to variables which do not have memory addresses, such as those the compiler chooses to put into registers. If you take the address of a local variable, it is very hard for the compiler to put it in a register.</li>\n</ul>\n\n<p>As an example:</p>\n\n<pre><code>void maybeModify(int&amp; x); // may modify x in some way\n\nvoid hurtTheCompilersOptimizer(short size, int array[])\n{\n    // This function is designed to do something particularly troublesome\n    // for optimizers. It will constantly call maybeModify on array[0] while\n    // adding array[1] to array[2]..array[size-1]. There's no real reason to\n    // do this, other than to demonstrate the power of references.\n    for (int i = 2; i &lt; (int)size; i++) {\n        maybeModify(array[0]);\n        array[i] += array[1];\n    }\n}\n</code></pre>\n\n<p>An optimizing compiler may realize that we are accessing a[0] and a[1] quite a bunch. It would love to optimize the algorithm to:</p>\n\n<pre><code>void hurtTheCompilersOptimizer(short size, int array[])\n{\n    // Do the same thing as above, but instead of accessing array[1]\n    // all the time, access it once and store the result in a register,\n    // which is much faster to do arithmetic with.\n    register int a0 = a[0];\n    register int a1 = a[1]; // access a[1] once\n    for (int i = 2; i &lt; (int)size; i++) {\n        maybeModify(a0); // Give maybeModify a reference to a register\n        array[i] += a1;  // Use the saved register value over and over\n    }\n    a[0] = a0; // Store the modified a[0] back into the array\n}\n</code></pre>\n\n<p>To make such an optimization, it needs to prove that nothing can change array[1] during the call. This is rather easy to do. i is never less than 2, so array[i] can never refer to array[1]. maybeModify() is given a0 as a reference (aliasing array[0]). Because there is no \"reference\" arithmetic, the compiler just has to prove that maybeModify never gets the address of x, and it has proven that nothing changes array[1].</p>\n\n<p>It also has to prove that there are no ways a future call could read/write a[0] while we have a temporary register copy of it in a0. This is often trivial to prove, because in many cases it is obvious that the reference is never stored in a permanent structure like a class instance.</p>\n\n<p>Now do the same thing with pointers</p>\n\n<pre><code>void maybeModify(int* x); // May modify x in some way\n\nvoid hurtTheCompilersOptimizer(short size, int array[])\n{\n    // Same operation, only now with pointers, making the\n    // optimization trickier.\n    for (int i = 2; i &lt; (int)size; i++) {\n        maybeModify(&amp;(array[0]));\n        array[i] += array[1];\n    }\n}\n</code></pre>\n\n<p>The behavior is the same; only now it is much harder to prove that maybeModify does not ever modify array[1], because we already gave it a pointer; the cat is out of the bag. Now it has to do the much more difficult proof: a static analysis of maybeModify to prove it never writes to &amp;x + 1. It also has to prove that it never saves off a pointer that can refer to array[0], which is just as tricky.</p>\n\n<p>Modern compilers are getting better and better at static analysis, but it is always nice to help them out and use references.</p>\n\n<p>Of course, barring such clever optimizations, compilers will indeed turn references into pointers when needed.</p>\n"
    },
    {
      "owner": {
        "reputation": 121694,
        "user_id": 48015,
        "user_type": "registered",
        "accept_rate": 80,
        "profile_image": "https://www.gravatar.com/avatar/0b722a5f7d2d809629ee40c63cc8576b?s=128&d=identicon&r=PG",
        "display_name": "Christoph",
        "link": "https://stackoverflow.com/users/48015/christoph"
      },
      "is_accepted": false,
      "score": 288,
      "last_activity_date": 1436304473,
      "last_edit_date": 1436304473,
      "creation_date": 1235770004,
      "answer_id": 596750,
      "question_id": 57483,
      "body": "<h1>What's a C++ reference (<em>for C programmers</em>)</h1>\n\n<p>A <em>reference</em> can be thought of as a <em>constant pointer</em> (not to be confused with a pointer to a constant value!) with automatic indirection, ie the compiler will apply the <code>*</code> operator for you.</p>\n\n<p>All references must be initialized with a non-null value or compilation will fail. It's neither possible to get the address of a reference - the address operator will return the address of the referenced value instead - nor is it possible to do arithmetics on references.</p>\n\n<p>C programmers might dislike C++ references as it will no longer be obvious when indirection happens or if an argument gets passed by value or by pointer without looking at function signatures.</p>\n\n<p>C++ programmers might dislike using pointers as they are considered unsafe - although references aren't really any safer than constant pointers except in the most trivial cases - lack the convenience of automatic indirection and carry a different semantic connotation.</p>\n\n<p>Consider the following statement from the <a href=\"https://isocpp.org/wiki/faq/references#overview-refs\" rel=\"noreferrer\"><em>C++ FAQ</em></a>:</p>\n\n<blockquote>\n  <p>Even though a reference is often implemented using an address in the\n  underlying assembly language, please do <em>not</em> think of a reference as a\n  funny looking pointer to an object. A reference <em>is</em> the object. It is\n  not a pointer to the object, nor a copy of the object. It <em>is</em> the\n  object.</p>\n</blockquote>\n\n<p>But if a reference <em>really</em> were the object, how could there be dangling references? In unmanaged languages, it's impossible for references to be any 'safer' than pointers - there generally just isn't a way to reliably alias values across scope boundaries!</p>\n\n<h1>Why I consider C++ references useful</h1>\n\n<p>Coming from a C background, C++ references may look like a somewhat silly concept, but one should still use them instead of pointers where possible: Automatic indirection <em>is</em> convenient, and references become especially useful when dealing with <a href=\"https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"noreferrer\">RAII</a> - but not because of any perceived safety advantage, but rather because they make writing idiomatic code less awkward.</p>\n\n<p>RAII is one of the central concepts of C++, but it interacts non-trivially with copying semantics. Passing objects by reference avoids these issues as no copying is involved. If references were not present in the language, you'd have to use pointers instead, which are more cumbersome to use, thus violating the language design principle that the best-practice solution should be easier than the alternatives.</p>\n"
    },
    {
      "owner": {
        "reputation": 26441,
        "user_id": 268,
        "user_type": "registered",
        "accept_rate": 100,
        "profile_image": "https://www.gravatar.com/avatar/c8e81676781ccc9caf74531a74d994aa?s=128&d=identicon&r=PG",
        "display_name": "Vincent Robert",
        "link": "https://stackoverflow.com/users/268/vincent-robert"
      },
      "is_accepted": false,
      "score": 56,
      "last_activity_date": 1436304353,
      "last_edit_date": 1436304353,
      "creation_date": 1221826999,
      "answer_id": 101406,
      "question_id": 57483,
      "body": "<p>Actually, a reference is not really like a pointer.</p>\n\n<p>A compiler keeps \"references\" to variables, associating a name with a memory address; that's its job to translate any variable name to a memory address when compiling.</p>\n\n<p>When you create a reference, you only tell the compiler that you assign another name to the pointer variable; that's why references cannot \"point to null\", because a variable cannot be, and not be.</p>\n\n<p>Pointers are variables; they contain the address of some other variable, or can be null. The important thing is that a pointer has a value, while a reference only has a variable that it is referencing.</p>\n\n<p>Now some explanation of real code:</p>\n\n<pre><code>int a = 0;\nint&amp; b = a;\n</code></pre>\n\n<p>Here you are not creating another variable that points to <code>a</code>; you are just adding another name to the memory content holding the value of <code>a</code>. This memory now has two names, <code>a</code> and <code>b</code>, and it can be addressed using either name.</p>\n\n<pre><code>void increment(int&amp; n)\n{\n    n = n + 1;\n}\n\nint a;\nincrement(a);\n</code></pre>\n\n<p>When calling a function, the compiler usually generates memory spaces for the arguments to be copied to. The function signature defines the spaces that should be created and gives the name that should be used for these spaces. Declaring a parameter as a reference just tells the compiler to use the input variable memory space instead of allocating a new memory space during the method call. It may seem strange to say that your function will be directly manipulating a variable declared in the calling scope, but remember that when executing compiled code, there is no more scope; there is just plain flat memory, and your function code could manipulate any variables.</p>\n\n<p>Now there may be some cases where your compiler may not be able to know the reference when compiling, like when using an extern variable. So a reference may or may not be implemented as a pointer in the underlying code. But in the examples I gave you, it will most likely not be implemented with a pointer.</p>\n"
    },
    {
      "owner": {
        "reputation": 6262,
        "user_id": 3655,
        "user_type": "registered",
        "accept_rate": 77,
        "profile_image": "https://www.gravatar.com/avatar/b2c73199029340cdb7a65d1aab554817?s=128&d=identicon&r=PG",
        "display_name": "Aardvark",
        "link": "https://stackoverflow.com/users/3655/aardvark"
      },
      "is_accepted": false,
      "score": 11,
      "last_activity_date": 1436304136,
      "last_edit_date": 1436304136,
      "creation_date": 1221226918,
      "answer_id": 58996,
      "question_id": 57483,
      "body": "<p>I use references unless I need either of these:</p>\n\n<ul>\n<li><p>Null pointers can be used as a\nsentinel value, often a cheap way to\navoid function overloading or use of\na bool.</p></li>\n<li><p>You can do arithmetic on a pointer.\nFor example, <code>p += offset;</code></p></li>\n</ul>\n"
    },
    {
      "owner": {
        "reputation": 81417,
        "user_id": 234,
        "user_type": "registered",
        "accept_rate": 62,
        "profile_image": "https://www.gravatar.com/avatar/3a9ff49a9e689dcbfc8242f05180cc31?s=128&d=identicon&r=PG",
        "display_name": "Orion Edwards",
        "link": "https://stackoverflow.com/users/234/orion-edwards"
      },
      "is_accepted": false,
      "score": 93,
      "last_activity_date": 1436304087,
      "last_edit_date": 1436304087,
      "creation_date": 1221171049,
      "answer_id": 57780,
      "question_id": 57483,
      "body": "<p>You forgot the most important part:</p>\n\n<p>member-access with pointers uses <code>-&gt;</code> <br/>\nmember-access with references uses <code>.</code></p>\n\n<p><code>foo.bar</code> is <em>clearly</em> superior to <code>foo-&gt;bar</code> in the same way that <a href=\"http://en.wikipedia.org/wiki/Vi\" rel=\"noreferrer\">vi</a> is <em>clearly</em> superior to <a href=\"http://en.wikipedia.org/wiki/Emacs\" rel=\"noreferrer\">Emacs</a> :-)</p>\n"
    },
    {
      "owner": {
        "reputation": 15851,
        "user_id": 168465,
        "user_type": "registered",
        "accept_rate": 87,
        "profile_image": "https://www.gravatar.com/avatar/f9a38df7ddf75a46b36c6a6ef5f98381?s=128&d=identicon&r=PG",
        "display_name": "kriss",
        "link": "https://stackoverflow.com/users/168465/kriss"
      },
      "is_accepted": false,
      "score": 9,
      "last_activity_date": 1430319654,
      "last_edit_date": 1430319654,
      "creation_date": 1264778118,
      "answer_id": 2162825,
      "question_id": 57483,
      "body": "<p>Another difference is that you can have pointers to a void type (and it means pointer to anything) but references to void are forbidden.</p>\n\n<pre><code>int a;\nvoid * p = &amp;a; // ok\nvoid &amp; p = a;  //  forbidden\n</code></pre>\n\n<p>I can't say I'm really happy with this particular difference. I would much prefer it would be allowed with the meaning reference to anything with an address and otherwise the same behavior for references. It would allow to define some equivalents of C library functions like memcpy using references.</p>\n"
    },
    {
      "owner": {
        "reputation": 1772,
        "user_id": 289442,
        "user_type": "registered",
        "accept_rate": 71,
        "profile_image": "https://www.gravatar.com/avatar/dc6e3178b871f5658c22ad2fea25c861?s=128&d=identicon&r=PG",
        "display_name": "George R",
        "link": "https://stackoverflow.com/users/289442/george-r"
      },
      "is_accepted": false,
      "score": 7,
      "last_activity_date": 1419685218,
      "creation_date": 1419685218,
      "answer_id": 27667467,
      "question_id": 57483,
      "body": "<p>Maybe some metaphors will help; \nIn the context of your desktop screenspace -   </p>\n\n<ul>\n<li>A reference requires you to specify an actual window.</li>\n<li>A pointer requires the location of a piece of space on screen that you assure it will contain zero or more instances of that window type.</li>\n</ul>\n"
    },
    {
      "owner": {
        "reputation": 264984,
        "user_id": 560648,
        "user_type": "registered",
        "accept_rate": 94,
        "profile_image": "https://i.stack.imgur.com/AkjZZ.jpg?s=128&g=1",
        "display_name": "Lightness Races in Orbit",
        "link": "https://stackoverflow.com/users/560648/lightness-races-in-orbit"
      },
      "is_accepted": false,
      "score": 24,
      "last_activity_date": 1414603043,
      "creation_date": 1414603043,
      "answer_id": 26636769,
      "question_id": 57483,
      "body": "<p>There is a semantic difference that may appear esoteric if you are not familiar with studying computer languages in an abstract or even academic fashion.</p>\n\n<p>At the highest-level, the idea of references is that they are transparent \"aliases\". Your computer may use an address to make them work, but you're not supposed to worry about that: you're supposed to think of them as \"just another name\" for an existing object and the syntax reflects that. They are stricter than pointers so your compiler can more reliably warn you when you about to create a dangling reference, than when you are about to create a dangling pointer.</p>\n\n<p>Beyond that, there are of course some practical differences between pointers and references. The syntax to use them is obviously different, and you cannot \"re-seat\" references, have references to nothingness, or have pointers to references.</p>\n"
    },
    {
      "owner": {
        "reputation": 244,
        "user_id": 3093272,
        "user_type": "registered",
        "accept_rate": 75,
        "profile_image": "https://www.gravatar.com/avatar/ca3508c6aeacb8c98c415ef0f9d94c62?s=128&d=identicon&r=PG",
        "display_name": "Tory",
        "link": "https://stackoverflow.com/users/3093272/tory"
      },
      "is_accepted": false,
      "score": 11,
      "last_activity_date": 1413322680,
      "creation_date": 1413322680,
      "answer_id": 26370807,
      "question_id": 57483,
      "body": "<p>At the risk of adding to confusion, I want to throw in some input, I'm sure it mostly depends on how the compiler implements references, but in the case of gcc the idea that a reference can only point to a variable on the stack is not actually correct, take this for example:</p>\n\n<pre><code>#include &lt;iostream&gt;\nint main(int argc, char** argv) {\n    // Create a string on the heap\n    std::string *str_ptr = new std::string(\"THIS IS A STRING\");\n    // Dereference the string on the heap, and assign it to the reference\n    std::string &amp;str_ref = *str_ptr;\n    // Not even a compiler warning! At least with gcc\n    // Now lets try to print it's value!\n    std::cout &lt;&lt; str_ref &lt;&lt; std::endl;\n    // It works! Now lets print and compare actual memory addresses\n    std::cout &lt;&lt; str_ptr &lt;&lt; \" : \" &lt;&lt; &amp;str_ref &lt;&lt; std::endl;\n    // Exactly the same, now remember to free the memory on the heap\n    delete str_ptr;\n}\n</code></pre>\n\n<p>Which outputs this:</p>\n\n<pre><code>THIS IS A STRING\n0xbb2070 : 0xbb2070\n</code></pre>\n\n<p>If you notice even the memory addresses are exactly the same, meaning the reference is successfully pointing to a variable on the heap! Now if you really want to get freaky, this also works:</p>\n\n<pre><code>int main(int argc, char** argv) {\n    // In the actual new declaration let immediately de-reference and assign it to the reference\n    std::string &amp;str_ref = *(new std::string(\"THIS IS A STRING\"));\n    // Once again, it works! (at least in gcc)\n    std::cout &lt;&lt; str_ref;\n    // Once again it prints fine, however we have no pointer to the heap allocation, right? So how do we free the space we just ignorantly created?\n    delete &amp;str_ref;\n    /*And, it works, because we are taking the memory address that the reference is\n    storing, and deleting it, which is all a pointer is doing, just we have to specify\n    the address with '&amp;' whereas a pointer does that implicitly, this is sort of like\n    calling delete &amp;(*str_ptr); (which also compiles and runs fine).*/\n}\n</code></pre>\n\n<p>Which outputs this:</p>\n\n<pre><code>THIS IS A STRING\n</code></pre>\n\n<p>Therefore a reference IS a pointer under the hood, they both are just storing a memory address, where the address is pointing to is irrelevant, what do you think would happen if I called std::cout &lt;&lt; str_ref; AFTER calling delete &amp;str_ref? Well, obviously it compiles fine, but causes a segmentation fault at runtime because it's no longer pointing at a valid variable, we essentially have a broken reference that still exists (until it falls out of scope), but is useless.</p>\n\n<p>In other words, a reference is nothing but a pointer that has the pointer mechanics abstracted away, making it safer and easier to use (no accidental pointer math, no mixing up '.' and '->', etc.), assuming you don't try any nonsense like my examples above ;)</p>\n\n<p>Now <strong>regardless</strong> of how a compiler handles references, it will <strong>always</strong> have some kind of pointer under the hood, because a reference <strong>must</strong> refer to a specific variable at a specific memory address for it to work as expected, there is no getting around this (hence the term 'reference').</p>\n\n<p>The only major rule that's important to remember with references is that they must be defined at the time of declaration (with the exception of a reference in a header, in that case it must be defined in the constructor, after the object it's contained in is constructed it's too late to define it).</p>\n\n<p><strong>Remember, my examples above are just that, examples demonstrating what a reference is, you would never want to use a reference in those ways! For proper usage of a reference there are plenty of answers on here already that hit the nail on the head</strong></p>\n"
    },
    {
      "owner": {
        "user_type": "does_not_exist",
        "display_name": "RichS"
      },
      "is_accepted": false,
      "score": 30,
      "last_activity_date": 1401662225,
      "last_edit_date": 1401662225,
      "creation_date": 1221163955,
      "answer_id": 57502,
      "question_id": 57483,
      "body": "<p>A reference can never be <code>NULL</code>.</p>\n"
    },
    {
      "owner": {
        "reputation": 497,
        "user_id": 2172349,
        "user_type": "registered",
        "accept_rate": 100,
        "profile_image": "https://www.gravatar.com/avatar/c893a1170d6d70035d553562da4cac5b?s=128&d=identicon&r=PG",
        "display_name": "Arlene Batada",
        "link": "https://stackoverflow.com/users/2172349/arlene-batada"
      },
      "is_accepted": false,
      "score": 9,
      "last_activity_date": 1363317110,
      "last_edit_date": 1363317110,
      "creation_date": 1363316588,
      "answer_id": 15423961,
      "question_id": 57483,
      "body": "<p>This program might help in comprehending the answer of the question. This is a simple program of a reference \"j\" and a pointer \"ptr\" pointing to variable \"x\".</p>\n\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\nint *ptr=0, x=9; // pointer and variable declaration\nptr=&amp;x; // pointer to variable \"x\"\nint &amp; j=x; // reference declaration; reference to variable \"x\"\n\ncout &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; endl;\n\ncout &lt;&lt; \"&amp;x=\" &lt;&lt; &amp;x &lt;&lt; endl;\n\ncout &lt;&lt; \"j=\" &lt;&lt; j &lt;&lt; endl;\n\ncout &lt;&lt; \"&amp;j=\" &lt;&lt; &amp;j &lt;&lt; endl;\n\ncout &lt;&lt; \"*ptr=\" &lt;&lt; *ptr &lt;&lt; endl;\n\ncout &lt;&lt; \"ptr=\" &lt;&lt; ptr &lt;&lt; endl;\n\ncout &lt;&lt; \"&amp;ptr=\" &lt;&lt; &amp;ptr &lt;&lt; endl;\n    getch();\n}\n</code></pre>\n\n<p>Run the program and have a look at the output and you'll understand.</p>\n\n<p>Also, spare 10 minutes and watch this video: <a href=\"https://www.youtube.com/watch?v=rlJrrGV0iOg\">https://www.youtube.com/watch?v=rlJrrGV0iOg</a></p>\n"
    },
    {
      "owner": {
        "reputation": 1331,
        "user_id": 1678760,
        "user_type": "registered",
        "accept_rate": 85,
        "profile_image": "https://i.stack.imgur.com/6TfNt.jpg?s=128&g=1",
        "display_name": "fatma.ekici",
        "link": "https://stackoverflow.com/users/1678760/fatma-ekici"
      },
      "is_accepted": false,
      "score": 20,
      "last_activity_date": 1357062346,
      "creation_date": 1357062346,
      "answer_id": 14112711,
      "question_id": 57483,
      "body": "<p>A reference is an alias for another variable whereas a pointer holds the memory address of a variable. References are generally used as function parameters so that the passed object is not the copy but the object itself. </p>\n\n<pre><code>    void fun(int &amp;a, int &amp;b); // A common usage of references.\n    int a = 0;\n    int &amp;b = a; // b is an alias for a. Not so common to use. \n</code></pre>\n"
    },
    {
      "owner": {
        "reputation": 42565,
        "user_id": 6210,
        "user_type": "registered",
        "accept_rate": 50,
        "profile_image": "https://www.gravatar.com/avatar/14994f4fef70636139dfeaf97dca2ef8?s=128&d=identicon&r=PG",
        "display_name": "MSN",
        "link": "https://stackoverflow.com/users/6210/msn"
      },
      "is_accepted": false,
      "score": 14,
      "last_activity_date": 1341326462,
      "last_edit_date": 1341326462,
      "creation_date": 1221262026,
      "answer_id": 60148,
      "question_id": 57483,
      "body": "<p>It doesn't matter how much space it takes up since you can't actually see any side effect (without executing code) of whatever space it would take up.</p>\n\n<p>On the other hand, one major difference between references and pointers is that temporaries assigned to const references live until the const reference goes out of scope.</p>\n\n<p>For example:</p>\n\n<pre><code>class scope_test\n{\npublic:\n    ~scope_test() { printf(\"scope_test done!\\n\"); }\n};\n\n...\n\n{\n    const scope_test &amp;test= scope_test();\n    printf(\"in scope\\n\");\n}\n</code></pre>\n\n<p>will print:</p>\n\n<pre><code>in scope\nscope_test done!\n</code></pre>\n\n<p>This is the language mechanism that allows ScopeGuard to work.</p>\n"
    },
    {
      "owner": {
        "reputation": 3482,
        "user_id": 838509,
        "user_type": "registered",
        "accept_rate": 67,
        "profile_image": "https://www.gravatar.com/avatar/c3baf4aa5bebf6d1407ed4e3b0981864?s=128&d=identicon&r=PG",
        "display_name": "Andrzej",
        "link": "https://stackoverflow.com/users/838509/andrzej"
      },
      "is_accepted": false,
      "score": 12,
      "last_activity_date": 1328518769,
      "creation_date": 1328518769,
      "answer_id": 9157689,
      "question_id": 57483,
      "body": "<p>There is one fundamental difference between pointers and references that I didn't see anyone had mentioned: references enable pass-by-reference semantics in function arguments. Pointers, although it is not visible at first do not: they only provide pass-by-value semantics. This has been very nicely described in <a href=\"http://javadude.com/articles/passbyvalue.htm\">this article</a>.</p>\n\n<p>Regards,\n&amp;rzej</p>\n"
    },
    {
      "owner": {
        "reputation": 26323,
        "user_id": 852,
        "user_type": "registered",
        "accept_rate": 67,
        "profile_image": "https://www.gravatar.com/avatar/01b30058589c398a1ac882c39d820538?s=128&d=identicon&r=PG",
        "display_name": "Matt Price",
        "link": "https://stackoverflow.com/users/852/matt-price"
      },
      "is_accepted": false,
      "score": 142,
      "last_activity_date": 1286556737,
      "last_edit_date": 1286556737,
      "creation_date": 1221169396,
      "answer_id": 57734,
      "question_id": 57483,
      "body": "<p>If you want to be really pedantic, there is one thing you can do with a reference that you can't do with a pointer: extend the lifetime of a temporary object. In C++ if you bind a const reference to a temporary object, the lifetime of that object becomes the lifetime of the reference.</p>\n\n<pre><code>std::string s1 = \"123\";\nstd::string s2 = \"456\";\n\nstd::string s3_copy = s1 + s2;\nconst std::string&amp; s3_reference = s1 + s2;\n</code></pre>\n\n<p>In this example s3_copy copies the temporary object that is a result of the concatenation. Whereas s3_reference in essence becomes the temporary object. It's really a reference to a temporary object that now has the same lifetime as the reference. </p>\n\n<p>If you try this without the <code>const</code> it should fail to compile. You cannot bind a non-const reference to a temporary object, nor can you take its address for that matter.</p>\n"
    }
  ],
  "has_more": true,
  "quota_max": 10000,
  "quota_remaining": 9942
}